## Chap6 内存管理
* 实模式、保护模式，如何进行模式切换(CRO的PE位)
* 如何启用分页机制(CRO的PG位)
* 段描述符的作用、组成
* 段选择符的作用、组成
* 保护模式下的地址转换过程
* 内核空间和用户空间
* 为什么采用三级分页模式
* 掌握虚拟地址空间和物理地址空间的管理方法
* Linux用户地址空间的分布
  * 为什么要划分一个个区VMA？VMA的查找、删除?
  * mm_struct， vm_area_struct的作用？
  * 描述task_struct,vm_area_struct、mm_struct、页目录表、物理内存之间的关系（结合图）
* Linux如何实现请求页
* 物理地址空间的页面的分配
  * 伙伴算法
  * free_area[],bitmap的作用
  * 结合free_area[],bitmap理解基于伙伴算法的物理页面的分配和回收，并能够会应用。
* 缺页异常处理过程
  * Do_page_fault()、handle_mm_fault(),handle_pte_fault()的作用
* Slab分配器的作用
* 掌握地址的变换。

* **地址变化**
* **伙伴系统**

### 1. Linux内存寻址
#### i386中的段寄存器
* 6个段寄存器，每个寄存器16位
* 保护模式下，16位的寄存器无法存放32位段基地址。段寄存器中存放的不是基地址，是段选择子
  * 段基地址存放在段描述符表中

#### i386中的状态和控制寄存器 
* 标志寄存器EFLAGS、指令指针EIP、机器状态字CR0、Intel保留CR1、页故障地址CR2、页目录地址CR3
* CR0控制寄存器
  * 机器状态字
    * PE(Protected Enable)用于启动保护模式、
      * 1保护模式；0实模式
    * PG(Paging Enable)分页允许位

![](2022-04-09-20-46-56.png)
* CR3页目录基地址寄存器
  * **保存页目录表的物理地址**，页目录表**总是放在以4K字节为单位的存储器边界上**——**低12位为0**
#### i386中的系统地址寄存器 
* **全局描述符表寄存器GDTR**
  * 48位寄存器，保存GDT的32位基地址和16位GDT的界限
* **局部描述符表寄存器LDTR**
  * 16位寄存器，保存局部描述符表LDT段的选择子

![](2022-04-09-20-58-37.png)
* CPU-(虚拟地址)->MMU(内存管理单元)-(物理地址)->存储器

#### 内存地址
* **逻辑地址**：每个逻辑地址由一个段(segment)和偏移量(offset)组成
* **线性地址**：32位无符号整数，可以表示**4G的地址空间**
* **物理地址**：用于芯片级内存单元寻址，与从CPU的地址引脚发送到内存总线上的电信号相对应
* **转换过程**
  * 逻辑地址-(分段单元)->线性地址-(分页单元)->物理地址

#### 段机制
* 段基址，界限，段属性

#### 段描述符
* 每个段由一个8个字节的段描述符来表示
  * 指出段的32位基地址(base字段)和20位段界限(limit字段) 
  * 第6个字节
    * G位：段界限粒度位，只对段界限有效
      * 当G=0时，表示段格式以字节长度
      * 当G=1时，表示段格式以4K字节为单位
    * D位：特殊位
  * 第5字节的第4位为0，说明是**系统段描述符**。

![](2022-04-09-21-12-29.png)

#### 段描述符表
* 定义i386所有段的情况，**描述符表占据一个字节为8的倍数的存储器空间**
* **全局描述符表GDT** (Global Description Table)
  
  * 除任务门、中断门和陷阱门描述符外，**包含着系统中所有任务共用段的描述符**
  * 存放**在RAM中**，使用一个专门的**寄存器GDTR指示GDT表在RAM中的位置**（物理起始地址）
* **局部描述符表LDT**（Local Description Table）
  * 包含**与给定任务有关的描述符** 
  * 存放**在RAM中**，使用LDTR来指示当前的LDT表
* **通常只定义一个GDT**，进程可根据需要创建附加的LDT

#### Intel CPU地址转换
* **实模式**(20位)
  * **16位段寄存器**只**记录段基址的高16位**，低4位全0，**必须4位对齐**
  * 不采用虚拟地址空间，**直接采用物理地址**空间
  * **物理地址=段寄存器值*16+段内偏移**
* **保护模式**(32位)
  * 配合**全局描述符表GDT**使用
  * GDT中记录了每个段的信息（段描述符），**段寄存器只需记录段在GDT中的序号**
  * **线性地址=段基地址+段内偏移**
  * **物理地址**：根据页表对线性地址进行转换而得到

#### 硬件中的分段
* I386体系结构采用**基于段选择子**的分段机制
* 逻辑地址=段：段内偏移
  * 段标识符：16位长，称为**段选择子**
  * 段内偏移：32位长
* 使用16位段寄存器来指明当前所使用的段
  * **索引号**:13位，**指定GDT表中的相应的段描述符**
  * **TI** (Table Indicator):1位，指明段描述符在 **GDT(TI=0)或LDT(TI=1)**中。
  * **RPL**(Request Privilege Level):2位，当相应段选择符装入到CS寄存器中时，指明CPU的当前特权级（用户/内核）

![](2022-04-09-21-34-31.png)
#### 段描述符的快速访问
* 16位段寄存器与GDT/LDT配合，对相应段寻址
* 在段选择子被装入段寄存器时，将相应的段描述符装入到对应的非编程寄存器，避免对GDT/LDT的访问

![](2022-04-09-21-36-05.png)

#### 逻辑地址到线性地址的转换
* 检查TI确定段描述符位置
* 从段选择子的index字段计算段描述符的地址
* 将逻辑地址的偏移量与段描述符base字段的值相加，得到线性地址

![](2022-04-09-21-37-01.png)

#### 硬件中的分页
* 分页单元(paging unit)
* 功能：线性地址$\to$物理地址
* 页(page):将线性地址分成以固定长度为单位的组
* 页表(page table)
  * 将线性地址映射到物理地址的数据结构
  * 存放在内存中，并在启用分页单元以前由内核对之进行初始化
* 页框(page frame)
  * 把所有RAM划分成以固定长度为单位的组
  * 每个页框可以包含一页，即页框长度等于页的长度
* 当PG=1时，启用分页;PG=0时，**线性地址被解释成物理地址**

#### 常规分页
* 一个页4k大$2^{12}$
* 32位地址分为3个域
  * 目录:最高10位，决定**目录项**
  * 页表：中间10位，决定**页表项**
  * 偏移量：低12位，页框内相对位置。
* 线性地址转换
  * 分两步，第一步**页目录表**，第二步**页表**
  * **正在用的页目录表存放在CR3寄存器中**
  * 每个页目录表项**4字节，最多1024项**

![](2022-04-09-21-49-43.png)

#### 二级模式线性地址转换的特点
* 减少每个进程页表所需RAM的数量
* 一级页表：需要$2^{20}$个表项(每项4字节，共4MB)
* 二级特点：
  * 每个活动进程**必须有一个页目录**，但**不必立即为进程的所有页表分配RAM**
  * 只为进程**实际使用的那些虚拟内存区请求页表**来减少内存需求
  * 页目录和页表都可以多达1024项$(2^{10})$
  * 一个页目录的寻址能力$1024\times1024\times4096=2^{32}$

#### 线性地址到物理地址的转换
* 第一步：形成**页表地址**
  * CR3包含着页目录的起始地址，用32位线性地址的最高10位A31～A22作为页目录的页目录项的索引，将它**乘以4(每项4个字节)**，与CR3中的页目录的起始地址相加，形成相应**页表地址**。
* 第二步：形成**页面地址**
  * 从指定的地址中取出32位页目录项，它的低12位为0，这32位是页表的起始地址。用32位线性地址中的A21～A12位作为页表中的页面的索引，将它**乘以4**，与页表的起始地址相加，形成32位**页面地址**。
* 第三步：形成32位物理地址
  * 将A11～A0作为相对于页面地址的偏移量，与32位页面地址相加，得到物理地址。

![](2022-04-09-22-01-02.png)

> * 线性地址空间是0x20000000到0x2003ffff(256KB)
>   * 空间大小为0x40000，即0x40个页(64页)

![](2022-04-09-22-04-07.png)

#### Linux进程的分页机制
* Linux的分段机制
  * 所有进程使用相同的段寄存器值及线性地址空间（0～4G）
* Linux对进程的处理很大程度上依赖于分页
  * 实际上，由硬件提供的MMU将线性地址自动转换为物理地址使得一下设计目标变得可行
  * 每个进程都有它自己的页全局目录和自己的页表集合


### 2. Linux页框管理
#### Linux的虚拟空间
* 每个进程拥有**3G用户空间**
* 内核占用**最高1G作为系统空间**
  * **系统空间由所有进程共享**

![](2022-04-09-22-17-52.png)
* 内存管理
  * **动态管理内核线性虚拟空间**
    * 物理地址空间到虚拟地址空间的映射
    * 属于稀缺资源，页框及内存区的分配与优化
      * 按需分配，不需要时释放
* 进程地址空间
  * **管理进程虚拟地址空间**
    * 编程地址空间与进程虚拟地址空间的映射
    * 进程虚拟地址空间与物理地址空间的映射

![](2022-04-09-22-29-10.png)

#### 页框设计
* 采用页作为内存管理的基本单位
* 标准页框大小为4KB
* 4KB是大多数磁盘块大小的倍数
  * 传输效率高
  * 管理方便

#### 页描述符
* 每个物理页框都用一个页描述符表示
* struct page 32字节
* 所有物理页框的描述符，组织在mem_map[]中
  * 所需空间略小于整个RAM的1%
  * virt_to_page(addr)宏产生线性地址addr对应的页描述符地址
  * pft_to_page(pfn)宏产生与页框号pfn对应的页描述符地址






### 3. Linux进程地址空间管理







