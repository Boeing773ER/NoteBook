# 数据库复习
**信南436**
* **题量大**
* 注重问题解决
* 知识点较少，填空简答Max20’
* 解决问题（大题）
* 关系代数表达查询 10'
* 熟练SQL语句 10-15'（不会太简单）多组连接，统计，子查询
* 概念模型的设计
* 逻辑模型的设计
* E/R图转换
* ↑20'
* 关系理论，键码求解（判断范式），模式分解
* 综合应用题8'设计的评价分析
* **熟练掌握部分**

## Chap1 数据库概念
* **数据**：能输入计算机并能被计算机程序识别和处理的符号集合。
* **数据库**：存储在计算机内的有组织，可共享的数据集合。
  1. 数据按一定数据模型组织，在描述和存储上具有较小的冗余度
  2. 数据间相互联系
  3. 由数据库管理系统进行管理
* 数据模型：指数据的组织方式，不但表达数据本身，而且表达数据间的联系，以及数据的一致性约束。
  * 三要素：数据结构、数据操作、数据约束。
  * 层次模型、网状模型、关系模型、面型对象的数据模型、对象关系数据模型、XML数据模型
* **数据库管理系统**(DBMS)：对**数据**统一**管理**和**控制**的软件系统。
  * **结构**：查询处理程序、事务管理程序、存储管理程序
* **数据库系统**：数据库+DBMS+应用程序+DBA+计算机系统平台
* **三级体系架构**：物理层--数据库、逻辑层--DBMS、视图层--用户，应用，应用服务器。
  * **视图层**描述用户使用的数据结构。
  * **逻辑层**描述数据库的逻辑结构
  * **物理层**描述数据如何储存。需要知道数据的存储路径，所需空间大小等。
* 数据独立性：**数据**与**应用程序**在一定程度上**相互分离**。
* 逻辑独立性：模式**改变**-->外模式/模式**映像改变**-->外模式**不变**-->应用程序不变。
* 物理独立性：内模式**改变**-->模式/内模式**映像改变**-->模式（尽量）**不变**-->**外模式和应用程序不变**。
* 文件系统：
  * 优点：数据可长期保存、物理结构与逻辑结构有简单区别、数据不属于某一特定程序
  * 缺点：没有同意的数据模型，数据访问困难、数据孤立，容易造成数据冗余和不一致、完整性问题--数据间需要满足的一种一致性约束、更新原子性、并发异常、安全性问题。

## Chap2 关系模型
### 2.1 关系数据模型
* **关系模型**：用二维表（集合）来组织数据及数据之间联系的模型。
* **元组**：表中每一行数据，相当于一个记录值。
* 关系模式：关系名与关系的属性集。S(a, b, c, d)
* 关系实例：对应一个关系模式的元组集合。
* 关系的特点：每个属性都是原子的（多值与组合属性不是）、各**属性不能重名**、行列次序不影响语义、**不能有相同行**。
* **键码**（候选码）：其值能唯一的标识一个元组，且该属性（组）的**任一真子集不能标识**。
  1. 唯一性
  2. 最小性
* **超码**：以键码作为子集的任意属性集。
* **主属性**：构成键码的属性。
* **非主属性**：不构成键码的属性。
* **外码**：关系R中的属性（组）X是另一个关系S的键码。
* **关系数据库**：若干关系构成的集合。数据组织方式用模式图表示。

### 2.2 关系代数
* **关系代数**：抽象的、过程化的查询语言。运算**对象和结果都是关系**。
#### 2.2.1 基本运算
* **传统运算**：交∩，并∪，差-，笛卡尔乘积x
* **关系运算**：选择$\sigma$，投影$\Pi$，改名运算$\rho$，连接运算。

#### 2.2.2 集合运算
* 并兼容关系：两个关系的属性**个数**，各属性**域**相同。
  * 设计运算：交并差

#### 2.2.3 集合运算
* 从关系R中选出满足条件表达式F的元组
$$
 \sigma_F(R)
$$
* F条件表达式：比较&逻辑运算符。

#### 2.2.4 投影
* 从某一关系R中选出某些属性A，构成新的关系
$$
\Pi_A(R)
$$
* 投影结果中**无重复元组**

#### 2.2.5 改名运算
* 把关系R的名称改成另一个名称s。一般对关系运算的结果改名
$$
\rho_s(R)
$$

#### 2.2.6 笛卡尔乘积运算
* R，S属性个数为m,n，元组个数为k<sub>1</sub>,k<sub>2</sub>
* 笛卡尔乘积是一个关系，属性个数m+n，元组个数k<sub>1</sub> $\times$ k<sub>2</sub>。记作
$$
 R \times S
$$

#### 2.2.7 $\theta$连接运算
* 两个关系的元组在满足某些条件下进行匹配，即$\theta$-连接。记为
$$
R \underset{\theta 条件}{\bowtie} S
$$
#### 2.2.8 自然连接
* 两个关系在**公共属性**上进行**等值连接**的运算。
$$
R \bowtie S
$$
#### 2.2.10 复合运算
$$
\Pi_{title, year}(\sigma_{studio="Fox"\bigwedge length\geq 100}(Movies))
$$

#### Example
* 找最大的一个值
$$
\Pi_{balance}(account)-\Pi_{a.balance}(\rho_a(account)\underset{a.balbance < d.balance}{\bowtie}\rho_d(account))
$$

### 2.3 关系的完整性
* 指采用关系模型存储的数据及其间的联系能够正确的表达现实世界。
* **实体完整性**：
  * 保证关系中每个元组都是**可识别**和**唯一**的。所有表都**必须有主键且非空**。
* **参照完整性**：
  * 一个表中的一个元组的存在以另一个表中某一元组的存在为**前提**。利用外码实现。
* **用户定义的完整性**：
  * 域完整性/语义完整性。值的取值范围。
* 插入时检查：实体完整性、参照完整性和用户定义的完整性。
* 删除时检查：参照完整性
* 更新时 = 先删除后插入。

## Chap3 数据库建模与实体联系模型
### 3.1 数据库设计的基本步骤
* 需求分析-->设计概念模型-->设计逻辑模型-->设计物理结构-->系统实现-->试运行及维护
### 3.2 实体-联系模型
#### 3.2.1 基本概念
* **实体**：现实世界中**客观存在**的一个具体或抽象事物，一个实体与其他实体**可以区分**。
* **属性**：描述实体特征的数据项。
  * 简单属性/组合属性；单值属性/多值属性；派生属性：由其他属性计算而来的属性
  * 传统关系模型中，**属性是简单，单值的**。
* **实体集**：具有**相同属性**的一类**实体的集合**。
* **联系**：实体间的**相互关系**。
* **联系集**：两个或多个实体集间，实体间**联系的总集合**。
  * 关系模型中，联系集可以用关系表示。元组中的各个原子来自联系集连接的各个实体。
  * 联系集可以有属性描述联系的特征。一个联系集的所有联系有**相同的属性**。
  * 联系集的度指联系集所**涉及的实体集个数**。
  * 二元联系类型：一对一、一对多、多对多。
    * 联系集联系的实体集中可以有实体没有联系关系。
#### 3.2.2 E-R图
* **多-->一，一<-->一，多--多** 
* **多元**联系**转二元**联系：**构造连接实体集E**
  * 将多远联系R用实体集E替换，生成E与其他实体集之间的联系$R_A$，$R_B$，$R_C$。原R的属性变为E的属性。
#### 3.2.3 E-R图设计问题
* **原则**：**忠实性**(以现实世界为唯一依据)，**避免冗余**(一个事物在一个数据库中只表达一次)，**尽量简单**。
* **步骤**：1.找实体集(n.)；2.找实体集属性；3.找联系(v.);
#### 3.2.4 约束的建模
* **键码**：能标识实体的最小属性集合。有若干键码是需要制定一个**主码**。
* **参照完整性约束**：E-->F的参照完整性约束。指E中存在一个实体e，则F中**必须存在**一个对应的实体f。**用E--)F表示**
* **域约束**：属性**类型**及**取值范围**的约束。
#### 3.2.5 子类实体
* 超类(学生)&子类(本科生)
* 子类**继承超类**的所有**属性和联系**。子类**没有自己的属性**时**不出现**在ER图中
#### 3.2.5 弱实体集
* 弱实体集：**没有主码**的实体集。用**双线矩形**表示，与**提供给他键码的实体集间的联系**用双线菱形。
* 多元联系集转化的实体集一般为弱实体集。
* 弱实体集键码：弱实体的属性+通过多对一联系从强实体集的键码。
### 3.3 ER模型向关系模型转换
#### 3.3.1 强实体集
实体集的主码和属性成为关系模式的主码和属性。
#### 3.3.2 弱实体集
* 关系模式的主属性 = 为弱实体集提供主码的强实体集的主码 + 弱实体集的主码。
* 全部属性 = 强实体集主属性 + 弱实体集所有属性。
#### 3.3.3 联系集的转化
* 为联系建立一个关系模式。相同属性名进行**改名**。
* **多对多**联系：**属性** = 联系本身 + 实体集键码。**键码** = 参与的实体集键码共同构成
* **一对多**：属性同多对多，键码 = 多侧的键码。
  * 可以不单独转化成关系模式，在多方中加联系属性和一方的键码。
* **一对一**联系：同一对多。
#### 3.3.4 子类实体集
* ISA不用转换，只用转换高一层和低一层的实体。
* **方法1**：父类实体建立一个关系模式。子类建立一个关系模式，继承父类的键码+自己的属性。
* **方法2**：**子类实体集不相交且覆盖父类全部范围时**。只给子类建关系模式。属性=父类属性+子类属性。



## Chap4 数据库设计理论
### 4.1 不好的关系模式的问题
* **数据冗余、插入删除异常**
### 4.2 函数依赖与范式定义
#### 4.2.1 函数依赖
* **函数依赖**：R(U)是属性集U上的关系模式。$X,Y\subseteq U$。若对于R(U)的任意一个关系r，以及r的任意两个元组t1,t2。**不存在**:t1[X]=t2[X]，t1[Y]=t2[Y]。则称X函数决定Y，Y函数依赖于X。记作$X\rightarrow Y$。
  * 注：需要对R(U)上**任意一个**关系实例**成立**。
* K是R的**候选码**，则$\forall\alpha\subset K, \alpha\nrightarrow R$
* **完全依赖**：$X\rightarrow Y$ 对X的任意真子集$X'$，都有$X'\nrightarrow Y$。记作$X \rightarrow^f Y$
* **部分依赖**：存在$X'\rightarrow Y$。记作$X \rightarrow^p Y$
* **传递依赖**：$X\rightarrow Y, Y\nrightarrow X, Y\nsubseteq X, Y\rightarrow Z$。记作$X \rightarrow^t Z$
* **非平凡的函数依赖**：$X\rightarrow Y, Y\nsubseteq X$
  * Exp：非平凡：$(A,B)\rightarrow C$ 平凡：$(A,B)\rightarrow B$
#### 4.2.2 范式定义
* **范式**：关系数据库中所有关系要满足的**属性间依赖的要求**。
* **1NF, 2NF, 3NF, BCNF, 4NF, 5NF**
1. **1NF**：关系模式的**各属性域**必须是**原子的**。
2. **2NF**：不存在非主属性对码的**部分依赖**。
3. **3NF**：不存在非主属性对码的**传递依赖**。
* **求解键码**：
  * **不出现**在依赖中或**只出现**在依赖**左边**的，是构成键码的属性
  * **只出现**在依赖**右边**的，**不是**构成键码的属性。
4. **BCNF**：R的每一个函数依赖$X\rightarrow Y$，$X$是超码。
   * **性质**：
     1. **所有非主属性完全依赖于每个键码**。
     2. 所有主属性完全依赖于不包含它的键码。
     3. 没有任何属性完全依赖与任一非主属性。
### 4.3 多值依赖与第四范式
#### 4.3.1 多值依赖
* **定义**：R(U), $X,Y,Z\subseteq U, Z = U-X-Y$。多值依赖$X\rightarrow\rightarrow Y$成立当且仅当R上任意一关系r，r在**X上的一个值对应唯一一组Y值**，且这组**Y值与Z的值无关**。
* **性质**：
  * **对称**性：若有$X\rightarrow\rightarrow Y, (Z=U-X-Y)$，则必有$X\rightarrow\rightarrow Z$
  * 平凡的多值依赖：$X\rightarrow\rightarrow Y, Z = U-X-Y=\emptyset$
  * 传递性：若$X\rightarrow\rightarrow Y, Y\rightarrow\rightarrow Z, (Z=U-X-Y)$，则$X\rightarrow\rightarrow Z$
#### 4.3.2 4NF
* 对于**每个非平凡的多值依赖**$X\rightarrow\rightarrow Y，X$都**是超码**。
* 符合4NF的范式符合BCNF
### 4.4 函数依赖理论
#### 4.4.1 函数依赖的逻辑蕴涵
* F是R给定的一组**函数依赖集合**，若能推出$X\rightarrow Y$，则记为$F\Rightarrow X\rightarrow Y$。F**蕴含**$X\rightarrow Y$
#### 4.4.2 函数依赖的闭包
* $F^+$：F及F所蕴含的所有函数依赖的集合
* **Armstrong公理：**
  * **自反**：if $\beta\subseteq\alpha$ then $\alpha \rightarrow \beta$
  * **增广**：if $\alpha \rightarrow \beta$ then $\gamma\alpha\rightarrow\gamma\beta$
  * **传递**：if $\alpha \rightarrow \beta, \beta \rightarrow \gamma$ then $\alpha \rightarrow \gamma$
* **Armstrong推理**：
  * 合并：if $\alpha \rightarrow \beta, \alpha \rightarrow \gamma$ then $\alpha \rightarrow \beta\gamma$
  * 分解：if $\alpha \rightarrow \beta\gamma$ then $\alpha \rightarrow \beta, \alpha \rightarrow \gamma$ 
  * 伪增广：if $X \rightarrow Y, Z \subseteq W$ then $XW \rightarrow YZ$
  * 伪传递：if $X \rightarrow Y, WY \rightarrow Z$ then $WX \rightarrow Z$
#### 4.4.3 属性的闭包
* F为属性U上的一组函数依赖的集合，$\alpha,\beta\subseteq U$，则$\alpha_F^+$称为属性集$\alpha$关于函数依赖集F的闭包
  * Exp:$R(A,B,C), F={A\rightarrow B, B\rightarrow C}, A_F^+=\{ABC\}$
#### 4.4.4 属性闭包的用途
* **确定键码**：AG是否为R的键码？==$R\subseteq AG^+?$
* **判断一个函数依赖是否属于$F^+$**：
  * Exp：$F=\{A\rightarrow B, B\rightarrow C\}, if AB\rightarrow C \in F^+?$
  * $\because(AB)_F^+ =\{ABC\}, C\subseteq (AB)_F^+ \therefore AB\rightarrow C \in F^+$
* **判断两个函数依赖是否等价**：
  * 若$F^+=G^+$F与G等价，记为F=G。
  * $F=G\Leftrightarrow F\subseteq G^+, G\subseteq F^+$
#### 4.4.5 正则覆盖
* **正则覆盖**：$F_m$是一个与$F$**等价**的**极小函数依赖集**，$F_m$中**无冗余函数依赖**。
  * 每个函数依赖**右部**仅含**一个属性**。
  * 每个函数依赖**左部没有多余**属性。
    1. 分解右部属性，去除多余依赖(被蕴含的依赖)
    2. 消除左部多余(分别令其中一个多余，检查多余后是否等价)
### 4.5 关系规范化
#### 4.5.1 模式分解
* 把一个关系模式$R$**分解为若干不想包含的关系模式**$\{R_1,R_2,R_3\}$
  * $R=R_1\bigcup R_2\bigcup R_3$
#### 4.5.2 关系投影
1. **无损接分解**：$R=R_1\bigcup R_2, r=\Pi_{R1}(r)\bowtie \Pi_{R2}(r)$
2. **有损接分解**：$R=R_1\bigcup R_2, r\neq\Pi_{R1}(r)\bowtie \Pi_{R2}(r)$
* 判断是否无损：$R(U,F)分解为\rho=\{R_1(U_1,F_1),R_2(U_2,F_2)\}$若$(U_1\bigcap U_2)\rightarrow (U_1-U_2)\in F^+ 或(U_1\bigcap U_2)\rightarrow (U_2-U_1)\in F^+$则**具有无损连接性**
* 对于分解成**多个子模式**时，使用**Chase检验**
  1. **赋初值**，Exp:R1(A,B),R2(B,C)则R1:A-a1,B-a2,C-b13,D-b14;R2:A-b21,B-a2,C-c3,D-b24
  2. 根据依赖集F修改矩阵元:用a替换b，用x小的bxy替换大的。**直至无变化**。
     * 当某列上的一个$b_{ij}$改为$b_{kj}$ (k＜j)或$a_j$时，应该把同一列、其它行上有取值为$b_{ij}$的矩阵元都要改成$b_{kj}$或$a_j$ 。
  3. 有一行全为a时，分解是无损连接的。
#### 4.5.3 依赖投影
* $F^+=\{F_1\bigcup F_2\bigcup F_3\}$
* $子模式R_i(U_i,F_i)，对所有A\subset U_i，计算A_F^+\bigcap U_i，依次构造F_i=\{A\rightarrow A_F^+\}$
* **保持依赖的分解**：$(F_1\bigcup F_2 \bigcup F_3)=F^+$
* **判定**保持函数依赖性的算法：
  1. 计算$G=\bigcup_{i=1}^kF_i$
  2. 若$F\subseteq G^+$则$\rho$是保持函数依赖性的。
#### 4.5.4 模式分解的准则及相关结论
* 一定可以**无损连接性**地分解称若干**BCNF**(even 4NF)子模式。
* 一定可以**保持函数依赖性**地分解成若干**3NF**子模式，不一定能达BCNF。
* 可以既无损连接性又保持函数依赖性的形成3NF子模式，不一定能形成BCNF子模式
#### 4.5.5 无损连接分解到BCNF
* 初始：$\rho=\{R(U_i,F_i)\}$
1. 找出不是BCNF的关系模式$R(U_i,F_i), \exist X\rightarrow Y \in F_i, X不含R_i键码$
2. $取A=X_{Fi}^+-X$
3. $R_i分为R_{i1}和R_{i2}，其中：R_{i1}=X_{Fi}^+，R_{i2}=U_i-A$
4. $计算F_i在R_{i1}和R_{i2}的投影，以及R_{i1}和R_{i2}的键码$
#### 4.5.6 保持依赖分解到3NF
初始模式：R(U,F)
1. 计算F的正则覆盖$F_m$
2. 若$F_m$中仅有一个函数依赖$X\rightarrow Y，且XY=U，则\rho=\{R(U,F_m)\}$算法结束。否则执行3.
3. 把U中与$F_m$的所有函数依赖的**左部和右部都无关的属性**，从U中分离出去，并使它们构成一个关系模式$R_0$(至少3NF)。设$F_m$剩余的属性构成属性集$U_0'$
4. 按照Fm中各函数依赖的左部属性，把$F_m$划分为$F_1$~$F_k$使得每个$F_i$的所有函数依赖的**左部**都相同
5. 根据$F_i$所包含的属性构造$U_i$。并由此构造关系模式$R_i(U_i,F_i)$。对于(i≠j),若$U_i\subseteq U_j$,则把$R_i$“合并”到$R_j$。

## Chap5 SQL
### 5.1 SQL概述
* SQL-Structured Query Language
* **特点**：综合统一、**高度非过程化**、**面向集合**的操作方法、既是自含式语言，又是嵌入式语言、语言简洁，语法简单。
### 5.2 查询语句基本结构
* Select ** From ** Where **;
  * Select = $\Pi$(投影)
  * Where = $\sigma$(条件)
* **查询结果为包**(bag)。
#### 5.2.1 Select子句
* Select后列出需要查询的属性，**允许**出现**重复元组**。
* **消重**：distinct；**不消重**：all。
* '*'表示所有属性；可以使用**四则运算表达式**对数字结果进行运算。
#### 5.2.2 Where子句
* 检索条件，使用'and','or'连接
#### 5.2.3 From子句
* 查询的数据源
* select * from A, B--查询A x B的所有信息
#### 5.2.4 改名运算
* 可改**属性名**与**关系名**
```SQL
Select A.Count as AC From Apple as A, Bear as B
```
#### 5.2.5 字符串运算
* 匹配运算符'**like**'
* '%'匹配任意长度子串；'_'匹配长度为1的子串。
```SQL
Where Maker like '%Boeing%'
```
* 通过转义字符'\'将'%','_'变为普通字符。
#### 5.2.6 排列元组
* 'order by' (属性) Desc(降序)/Asc(升序)
#### 5.2.7 集合运算
* union $\bigcup$；intersect $\bigcap$；except '-'
* 在两个查找结果间运算
* **自动删除重复元组**；保留重复元组在命令后+'all'。
#### 5.2.8 聚集函数
* **avg, min, max, sum, count**。
```SQL
Select avg(balance) From account where branch-name='A';
Select count(*) form account;
```
* **select后不在聚集函数中的属性必须出现在group by子句中**。
```SQL
Select branch-name, avg(balance) 
From account group by branch-name having avg(balance)>500;
```
* having出现在Group by后，是**分组统计后的输出条件**，where是**查询条件**。
#### 5.2.9 空值Null Values
* 'null'信息确实或不确定；用'is null'进行测试
* **涉及null的数学运算结果为null**；聚集函数忽略null；null**与任意值比较**返回unknown
* 'unknown'是三种布尔值的一种。在where的条件子句中，返回**unknown当false处理**。
#### 5.2.10 嵌套子查询
* **in, not in, 集合比较(some, any, all), exist, unique**。
* 一个查询可以使用另一个查询的结果。
```SQL
集合运算：
(SELECT customer-num FROM depositor)
intersect
(SELECT customer-num FROM borrower)
嵌套子查询：
SELECT distinct customer-num FROM borrower where customer-num
in(SELECT customer-num from depositor)
```
资产比位于Brooklyn的**某一家**支行高的支行名
```SQL
集合比较：
SELECT branch-num FROM branch WHERE assets >
some(SELECT assets FROM branch WHERE branch-city = 'Brooklyn')
```
* **相关子查询**：内层查询涉及到外层查询的数据。可以是exist, 比较运算, IN。
* 空集测试'exists'
```SQL
SELECT customer-num FROM borrower as b WHERE exists 
(SELECT * FROM depositor as d WHERE d.coustomername=b.coustomername)
```
#### 5.2.11 连接运算(SQL2)
* FROM table1 join_type table2 [ON〈连接条件表达式〉]
* A inner join B 取交集。
* A left join B 取 A 全部，B 没有对应的值为 null。
* A right join B 取 B 全部 A 没有对应的值为 null。
* A full outer join B 取并集，彼此没有对应的值为 null。
* 自然连接'natural'：**自动省略连接关键字**。
* 'using'用法
```SQL
SELECT * FROM book JOIN borrow USING (book_id);
SELECT * FROM book JOIN borrow WHERE book.book_id = borrow.book_id;
```
### 5.3 数据定义语句
* 功能：定义数据库、关系、索引、约束、视图、完全、物理存贮结构等
* 创建(CREATE)，删除(DROP)，修改(ALTER，只有表)
#### 5.3.1 创建表
```SQL
CREATE TABLE <表名>(
<列名><数据类型>[列级完整性约束定义],
表级完整性约束定义
);
CREATE TABLE stand(
    airport_IATA_code varchar(20) not null,
    stand_num         varchar(20) not null,
    primary key (airport_IATA_code, stand_num),
    foreign key (airport_IATA_code) references airport (airport_IATA_code)
);
```
* **允许的完整性约束**：
  * primary key(A1,...,An) 主码约束
  * foreign key() references tableA() 外码约束
  * not null 非空约束
  * unique 取值唯一约束
  * default(默认值) 缺省值约束
  * check(P) 取指范围约束
#### 5.3.2 删除表或修改表结构
```SQL
删除表：DROP TABLE <表名>
修改表：
ALTER TABLE <表名>
    ALTER COLUMN <列名><新数据类型>
    ADD [COLUMN] <列名><数据类型>[约束]
    DROP COLUMN <列名>
    ADD PRIMARY KEY (列名,列名)
    ADD FOREIGN KEY (列名) references table <表名>(列名);
```
#### 5.3.3 创建和删除索引
* **索引目的**：**加快查询速度**。
```SQL
创建：CREATE INDEX Indamount ON brach(amount ASC, balance DESC);
删除：DROP INDEX Indamount;
```
#### 5.3.4 创建和删除视图
* 视图是**虚表**，**从用户的角度隐藏数据**，简化查询书写方式的机制
* **作用**：**保护数据**，**简化查询**。
```SQL
CREATE VIEW v1 as <查询语句>
DROP VIEW v1
```
* 查询时视图当表使用
### 5.4 数据更新语句
* 插入(insert), 删除(delete), 更新(upadate)
```SQL
数据删除：DELETE FROM <表名> WHERE <条件>
数据插入：INSERT INTO <表名>[(属性1,属性2)] values(值1,值2)
数据更新：UPDATE <表名> SET <列名>=<表达式> WHERE <条件>
update account set balance = balance*1.06 where balance > 10000
```

## Chap6 SQL约束
### 6.1 SQL中的键码约束和单值约束
* Primary key 和unique的**区别**：
  * Primary Key只能出现一次，Unique可以出现多次。
  * Primary Key**必须not null**，Unique可以取空。
* **作用**：当对表进行**插入**、**修改**操作时，DBMS将进行主码约束或单值**约束检查**。
### 6.2 属性取值的约束
* 位于每列定义后，列级约束。
* NOT NULL 非空约束
* CHEKC( Sex IN('F','M')), CHECK(Age>15)
### 6.3 全局约束(元组间的约束)
* 位于所有列定义结束后
* 年龄够大才能用Dr.头衔：CHECK(( NOT(Title = 'Dr.%') OR (Birthdate < '01/01/1981'))
### 6.4 参照完整性约束
* R1：主码key1(被参照关系)<--R2：key2(参照关系)
* 关系R2中，任一元组在外码FK上的取值：
  1. **等于主码key1的值**
  2. **为null**
* 当数据库进行**修改时**，参照完整性应**检查修改结果是否正确**
* 三种更新策略：
  1. 破坏参照完整性时，拒绝更新
  2. 级联CASCADE：**删改被参照**关系元组时，级联的**删改参照关系**中外码所在的元组或外码属性值
  3. 置空：**删改被参照**关系元组时，把**参照关系**中对应外码的值置为null。
### 6.5 断言 assertion
* **断言**指数据库中数据要满足的条件。
* **约束是断言的特殊形式**。
* **create assertion <断言名>check(条件)**
### 6.6 触发器 trigger
* 触发器**是一个语句集合（规则）**，当**数据库作修改时**，被系统**自动执行**。
* 定义时指明两点：
  1. 什么条件下执行：引起触发器被检测的事件；触发器执行下去的条件。
  2. 触发器执行时采取的动作
* 引起触发事件：Update、Insert、Delete。
* **特征**：
  1. 可以在**触发事件之前或之后**被执行。用befor/after声明
  2. 条件用When语句给出
  3. 触发器动作执行的方式有两种:
     * 一次针对一个元组：for each row
     * 一次针对事件操作中被改变的所有元组
  4. 创建语句用Create trigger

## Chap7 数据库的安全与控制
### 7.1 数据库安全模型
#### 7.1.1 数据库安全
保护数据库，**防止因用户非法使用数据库**造成数据泄露、更改或破坏。
#### 7.1.2 安全性控制的一般方法
1. 用户身份的标识和鉴定。
2. 角色管理--**存取权限控制**。
3. 定义并使用**视图**。
4. 审计制度。
5. 数据加密。
#### 7.1.3 存取权限基本类型
* 存取权限基本类型：**读取**、**插入**、**更新**、**删除**。
* 权限可以由于**一个用户传递给另一个用户**，用**授权图**表示。
  * 每个节点为一个用户，**根节点为DBA**
  * 每条边需要与根节点相连。
  * DBA/有授权能力的用户可以**授予/回收其他用户的权限**。
#### 7.1.4 SQL授权语句
* SQL中试用GRANT和REVOKE进行授权。
* **[WITH GRANT OPTION]**：该用户可以将<权限表>中的权限授权给其他用户。
* **[CASCADE]**：将该用户授权给其他用户的<权限表>中的权限也收回。
```SQL
授权语句格式：
GRANT <权限表> ON <关系/视图名> TO <用户表> [WITH GRANT OPTION]
GRANT SELECT, INSERT ON Student TO User1, User2 WITH GRANT OPTION
收回权限语句格式：
REVOKE <权限表> ON <关系/视图> FROM <用户表> [CASCADE]
REVOKE INSERT ON Student FROM User1 CASCADE
REVOKE GRANT OPTION FOR SELECT ON Student FROM User2 CASCADE
```
* **最小为表**，**不支持元组**级权限控制。
### 7.2 事务管理
* 事务：访问并可能**更新**数据库**数据**的一个**程序执行单位**。
  * **性质**(**ACID**)：
    1. **原子性**(**A**tomicity)：组成事务的**操作**的**不可分割**性。
    2. **一致性**(**C**onsistency)：事务必须是**正确的程序**，使数据库从一个一致状态转变为另一个一致状态。
    3. **隔离性**(**I**solation)：**正在执行**的事务在**提交之前**，不允许把其对共享数据的改变，交给给其它事务使用。
    4. **持久新**(**D**urability)：事物**提交后**，其执行**结果不能丢失**(即使数据库故障)。
### 7.3 事务的并发控制
* **并发**：多个事务同时存取相同的数据。
  * 引起的问题：数据一致性问题
    1. 丢失修改
    2. 写入脏数据
    3. 不可重复的读
#### 7.3.3 封锁Locking
* 类型：
  1. **排它锁(X)**：**写锁**，**拒绝**其它事务**任何类型**的锁请求。
  2. **共享锁(S)**：**读锁**，**拒绝**其它事务的**X锁请求**，**允许**其它事务的**S锁请求**。
#### 7.3.4 三级锁协议--解决一致性问题
* **一级**锁协议(解决**修改丢失**)：**修改**数据D**之前**，先对其**加X锁**，直到事务**结束**再**释放该锁**。
  * 加X锁--修改数据D--**事务结束/回退**--解X锁。
* **二级**锁协议(解决**读脏数据**)：**在一级锁**的基础上，**读取**数据D之**前**，对其**加S锁**，**读完后**即可**立即释放S锁**。
  * 加S锁--读数据D--解S锁
* **三级**锁协议(解决**不可重复读**)：**在一级锁**的基础上，**读取**数据D之**前**，对其**加S锁**，直到事务**结束**再**释放该锁**。
  * 加S锁--修改数据D--**事务结束/回退**--解S锁。
* **两阶段**锁协议：事务**分两个阶段提出锁操作**。
  1. **获得锁**阶段：任何事务可以申请**获得锁**，但**不能释放锁**。
  2. **释放锁**阶段：任何事务可以申请**释放锁**，但**不能获得新锁**。
* 并发调度的**可串行性**：
  * **可串行化**：多个事务的**并发调度**执行过程**结果**与**串行**执行过程**结果**相同
  * 如果所有事务**都遵守两端锁**协议，则他们是**可串行化**的。
#### 7.3.5 SQL标准的隔离性级别
* 隔离性级别：多个事务**并发执行时**，一个事务所**能容忍干扰的程度**。
  1. SERIALIZABLE--可串行化
  2. READ UNCOMMITTED--**允许读脏数据**
  3. READ COMMITTED--**禁止读脏数据，允许不可重复的读**
  4. REPEATABLE READ--**允许可重复的读**

